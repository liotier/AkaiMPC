<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>MPC Chord Progression Analyzer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    :root {
      --bg: #ffffff;
      --fg: #1a1a1a;
      --muted: #6b7280;
      --border: #e5e7eb;
      --pad-bg: #f9fafb;
      --pad-hover: #f3f4f6;
      --accent: #3b82f6;
      --accent-dark: #2563eb;
      --success: #10b981;
      --warning: #f59e0b;
      --error: #ef4444;
      --radius: 8px;
      --font-mono: 'Fira Code', 'Monaco', monospace;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg);
      color: var(--fg);
      line-height: 1.6;
      padding: 20px;
      max-width: 1400px;
      margin: 0 auto;
    }
    
    h1 {
      font-size: 28px;
      font-weight: 700;
      margin-bottom: 8px;
    }
    
    .subtitle {
      color: var(--muted);
      margin-bottom: 24px;
    }
    
    /* Loading State */
    .loading {
      display: none;
      align-items: center;
      gap: 12px;
      padding: 12px;
      background: var(--accent);
      color: white;
      border-radius: var(--radius);
      margin-bottom: 16px;
    }
    
    .loading.active {
      display: flex;
    }
    
    .spinner {
      width: 20px;
      height: 20px;
      border: 2px solid rgba(255,255,255,0.3);
      border-top-color: white;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Drop Zone */
    .drop-zone {
      border: 2px dashed var(--border);
      border-radius: var(--radius);
      padding: 40px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      margin-bottom: 24px;
      background: var(--pad-bg);
    }
    
    .drop-zone:hover {
      border-color: var(--accent);
      background: var(--pad-hover);
    }
    
    .drop-zone.dragging {
      border-color: var(--accent);
      background: #eff6ff;
      transform: scale(1.02);
    }
    
    .drop-zone input[type="file"] {
      display: none;
    }
    
    /* Stats Bar */
    .stats-bar {
      display: flex;
      gap: 24px;
      padding: 16px;
      background: var(--pad-bg);
      border-radius: var(--radius);
      margin-bottom: 24px;
      flex-wrap: wrap;
    }
    
    .stat {
      display: flex;
      flex-direction: column;
    }
    
    .stat-label {
      font-size: 12px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    
    .stat-value {
      font-size: 24px;
      font-weight: 700;
      color: var(--fg);
    }
    
    /* Filter Section */
    .filters {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      margin-bottom: 24px;
    }
    
    .filter-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .filter-group label {
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      color: var(--muted);
      letter-spacing: 0.05em;
    }
    
    select, input, button {
      padding: 8px 12px;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      font-size: 14px;
      background: white;
      transition: all 0.2s ease;
    }
    
    select:focus, input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }
    
    button {
      cursor: pointer;
      font-weight: 500;
    }
    
    button:hover {
      background: var(--pad-hover);
    }
    
    button.primary {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }
    
    button.primary:hover {
      background: var(--accent-dark);
    }
    
    /* Chord Builder */
    .chord-builder {
      grid-column: span 2;
      padding: 16px;
      background: var(--pad-bg);
      border-radius: var(--radius);
    }
    
    .chord-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 12px;
      min-height: 32px;
    }
    
    .chord-tag {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      background: var(--accent);
      color: white;
      border-radius: 20px;
      font-size: 14px;
      animation: tagSlide 0.3s ease;
    }
    
    @keyframes tagSlide {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .chord-tag button {
      background: none;
      border: none;
      color: white;
      padding: 0;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: background 0.2s;
    }
    
    .chord-tag button:hover {
      background: rgba(255,255,255,0.2);
    }
    
    /* Progression Cards */
    .progressions {
      display: grid;
      gap: 20px;
    }
    
    .progression-card {
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 20px;
      background: white;
      transition: all 0.2s ease;
    }
    
    .progression-card:hover {
      box-shadow: 0 4px 12px rgba(0,0,0,0.05);
      transform: translateY(-2px);
    }
    
    .progression-header {
      display: flex;
      justify-content: space-between;
      align-items: start;
      margin-bottom: 16px;
    }
    
    .progression-title {
      font-size: 18px;
      font-weight: 600;
    }
    
    .progression-meta {
      display: flex;
      gap: 16px;
      margin-top: 4px;
      font-size: 14px;
      color: var(--muted);
    }
    
    .progression-meta .key {
      color: var(--success);
      font-weight: 500;
    }
    
    .progression-meta .pattern {
      color: var(--warning);
      font-weight: 500;
    }
    
    /* Chord Grid */
    .chord-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 12px;
    }
    
    .chord-pad {
      background: var(--pad-bg);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
      overflow: hidden;
    }
    
    .chord-pad:hover {
      background: var(--pad-hover);
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    
    .chord-pad.playing {
      animation: pulse 0.3s ease;
      background: #dbeafe;
      border-color: var(--accent);
    }
    
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    
    .pad-number {
      font-size: 11px;
      color: var(--muted);
      font-weight: 600;
      text-transform: uppercase;
      margin-bottom: 4px;
    }
    
    .chord-name {
      font-size: 20px;
      font-weight: 700;
      margin-bottom: 4px;
      color: var(--fg);
    }
    
    .chord-quality {
      font-size: 13px;
      color: var(--accent);
      font-weight: 500;
      margin-bottom: 8px;
    }
    
    .chord-intervals {
      font-size: 11px;
      color: var(--muted);
      font-family: var(--font-mono);
      margin-bottom: 4px;
    }
    
    .chord-roman {
      font-size: 14px;
      font-weight: 600;
      color: var(--warning);
      margin-bottom: 4px;
    }
    
    .chord-notes {
      font-size: 11px;
      color: var(--muted);
      font-family: var(--font-mono);
      word-break: break-all;
    }
    
    /* Play Controls */
    .play-controls {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    
    .tempo-control {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
    }
    
    .tempo-control input {
      width: 60px;
    }
    
    /* Group Headers */
    .group-header {
      background: var(--pad-bg);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 16px;
      margin-bottom: 12px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: 600;
      transition: all 0.2s ease;
    }
    
    .group-header:hover {
      background: var(--pad-hover);
    }
    
    .group-header .toggle {
      transition: transform 0.3s ease;
    }
    
    .group-header.collapsed .toggle {
      transform: rotate(-90deg);
    }
    
    .group-content {
      margin-left: 16px;
      margin-bottom: 16px;
      transition: all 0.3s ease;
    }
    
    .group-content.collapsed {
      display: none;
    }
    
    /* Utility Classes */
    .hidden { display: none !important; }
    .flex { display: flex; }
    .gap-8 { gap: 8px; }
    .gap-16 { gap: 16px; }
    
    @media (max-width: 768px) {
      .filters {
        grid-template-columns: 1fr;
      }
      
      .chord-grid {
        grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      }
      
      .progression-header {
        flex-direction: column;
        gap: 12px;
      }
    }
  </style>
</head>
<body>
  <h1>MPC Chord Progression Analyzer</h1>
  <p class="subtitle">Pure interval-based chord analysis from MIDI notes • No name assumptions</p>
  
  <div class="loading" id="loading">
    <div class="spinner"></div>
    <span>Processing files...</span>
  </div>
  
  <div class="drop-zone" id="dropZone">
    <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin: 0 auto 12px; opacity: 0.3;">
      <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
      <polyline points="17 8 12 3 7 8"></polyline>
      <line x1="12" y1="3" x2="12" y2="15"></line>
    </svg>
    <p><strong>Drop .progression files here</strong></p>
    <p style="color: var(--muted); font-size: 14px; margin-top: 8px;">or click to browse</p>
    <input type="file" id="fileInput" accept=".progression,.json" multiple>
  </div>
  
  <div class="stats-bar hidden" id="statsBar">
    <div class="stat">
      <span class="stat-label">Total</span>
      <span class="stat-value" id="statTotal">0</span>
    </div>
    <div class="stat">
      <span class="stat-label">Shown</span>
      <span class="stat-value" id="statShown">0</span>
    </div>
    <div class="stat">
      <span class="stat-label">Unique Keys</span>
      <span class="stat-value" id="statKeys">0</span>
    </div>
    <div class="stat">
      <span class="stat-label">Unique Chords</span>
      <span class="stat-value" id="statChords">0</span>
    </div>
  </div>
  
  <div class="filters hidden" id="filters">
    <div class="filter-group">
      <label>Root Note</label>
      <select id="filterRoot">
        <option value="">All roots</option>
      </select>
    </div>
    
    <div class="filter-group">
      <label>Scale/Mode</label>
      <select id="filterScale">
        <option value="">All scales</option>
      </select>
    </div>
    
    <div class="filter-group">
      <label>Pattern Search</label>
      <input type="text" id="filterPattern" placeholder="e.g., I-V-vi-IV">
    </div>
    
    <div class="filter-group">
      <label>Progression Name</label>
      <input type="text" id="filterName" placeholder="Search by name...">
    </div>
    
    <div class="chord-builder">
      <label>Chord Filter (must contain all)</label>
      <div class="flex gap-8">
        <select id="chordFilterNote">
          <option value="">Select note...</option>
        </select>
        <select id="chordFilterQuality">
          <option value="">Select quality...</option>
        </select>
        <button class="primary" id="addChordFilter">Add Chord</button>
        <button id="clearAllFilters">Clear All</button>
      </div>
      <div class="chord-tags" id="chordTags"></div>
    </div>
    
    <div class="filter-group">
      <label>Display Options</label>
      <div class="flex gap-16" style="margin-top: 8px;">
        <label style="display: flex; align-items: center; gap: 4px; font-size: 14px;">
          <input type="checkbox" id="groupByKey"> Group by key
        </label>
        <label style="display: flex; align-items: center; gap: 4px; font-size: 14px;">
          <input type="checkbox" id="showIntervals" checked> Show intervals
        </label>
      </div>
    </div>
  </div>
  
  <div class="progressions" id="progressions"></div>

<script>
// Constants
const NOTES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
const ENHARMONICS = {
  'C#': 'Db', 'D#': 'Eb', 'F#': 'Gb', 'G#': 'Ab', 'A#': 'Bb',
  'Db': 'C#', 'Eb': 'D#', 'Gb': 'F#', 'Ab': 'G#', 'Bb': 'A#',
  'Cb': 'B', 'B#': 'C', 'E#': 'F', 'Fb': 'E'
};

const SCALES = {
  'Major': [0, 2, 4, 5, 7, 9, 11],
  'Natural Minor': [0, 2, 3, 5, 7, 8, 10],
  'Harmonic Minor': [0, 2, 3, 5, 7, 8, 11],
  'Melodic Minor': [0, 2, 3, 5, 7, 9, 11],
  'Dorian': [0, 2, 3, 5, 7, 9, 10],
  'Phrygian': [0, 1, 3, 5, 7, 8, 10],
  'Lydian': [0, 2, 4, 6, 7, 9, 11],
  'Mixolydian': [0, 2, 4, 5, 7, 9, 10],
  'Locrian': [0, 1, 3, 5, 6, 8, 10]
};

const INTERVAL_NAMES = [
  'R', 'm2', 'M2', 'm3', 'M3', 'P4', 'TT', 'P5', 'm6', 'M6', 'm7', 'M7'
];

// Global state
let progressions = [];
let chordFilters = [];
let audioContext = null;
let isPlaying = false;
let playbackTimeout = null;

// Utility functions
function normalizeNote(note) {
  if (!note) return null;
  let normalized = note.trim().toUpperCase();
  
  // Handle flats
  normalized = normalized.replace(/♭/g, 'b').replace(/♯/g, '#');
  
  // Remove octave numbers
  normalized = normalized.replace(/[0-9]/g, '');
  
  // Convert flats to sharps for consistency
  if (normalized.includes('b') && ENHARMONICS[normalized]) {
    normalized = ENHARMONICS[normalized];
  }
  
  return NOTES.includes(normalized) ? normalized : null;
}

function midiToNote(midi) {
  return NOTES[midi % 12];
}

function midiToNoteName(midi) {
  const note = NOTES[midi % 12];
  const octave = Math.floor(midi / 12) - 2;
  return note + octave;
}

function noteToMidi(note, octave = 4) {
  const index = NOTES.indexOf(normalizeNote(note));
  if (index === -1) return null;
  return index + (octave + 2) * 12;
}

// Pure interval-based chord analysis
function analyzeChord(midiNotes) {
  if (!midiNotes || midiNotes.length === 0) {
    return { root: null, quality: 'Empty', intervals: [], name: '?' };
  }
  
  if (midiNotes.length === 1) {
    const root = midiToNote(midiNotes[0]);
    return { root, quality: 'Single Note', intervals: [0], name: root };
  }
  
  // Sort notes and find the lowest as potential root
  const sorted = [...midiNotes].sort((a, b) => a - b);
  const bassNote = sorted[0];
  const bassPC = bassNote % 12;
  
  // Calculate intervals from bass note
  const intervals = [];
  const uniquePCs = new Set();
  
  for (const note of sorted) {
    const pc = note % 12;
    uniquePCs.add(pc);
    const interval = (pc - bassPC + 12) % 12;
    if (!intervals.includes(interval)) {
      intervals.push(interval);
    }
  }
  
  intervals.sort((a, b) => a - b);
  
  // Analyze chord quality based on intervals
  const { quality, root } = identifyChordQuality(intervals, bassPC);
  
  // Build chord name
  const rootNote = NOTES[root];
  let chordName = rootNote;
  
  // Add quality suffix
  if (quality !== 'Major') {
    const qualitySuffixes = {
      'Minor': 'm',
      'Diminished': 'dim',
      'Augmented': 'aug',
      'Dominant 7': '7',
      'Major 7': 'maj7',
      'Minor 7': 'm7',
      'Half-Diminished 7': 'ø7',
      'Diminished 7': 'dim7',
      'Sus2': 'sus2',
      'Sus4': 'sus4',
      'Major 6': '6',
      'Minor 6': 'm6',
      'Add9': 'add9',
      'Major 9': 'maj9',
      'Minor 9': 'm9',
      '11th': '11',
      '13th': '13'
    };
    chordName += qualitySuffixes[quality] || '';
  }
  
  // Add slash if bass note differs from root
  if (bassPC !== root) {
    chordName += '/' + NOTES[bassPC];
  }
  
  return {
    root: rootNote,
    quality,
    intervals,
    name: chordName,
    bassNote: NOTES[bassPC]
  };
}

function identifyChordQuality(intervals, bassPC) {
  const hasInterval = (i) => intervals.includes(i);
  
  // Convert intervals to string for pattern matching
  const pattern = intervals.join(',');
  
  // Extended chord patterns with root position
  const patterns = {
    // Triads
    '0,4,7': { quality: 'Major', root: 0 },
    '0,3,7': { quality: 'Minor', root: 0 },
    '0,3,6': { quality: 'Diminished', root: 0 },
    '0,4,8': { quality: 'Augmented', root: 0 },
    '0,2,7': { quality: 'Sus2', root: 0 },
    '0,5,7': { quality: 'Sus4', root: 0 },
    
    // 7th chords
    '0,4,7,10': { quality: 'Dominant 7', root: 0 },
    '0,4,7,11': { quality: 'Major 7', root: 0 },
    '0,3,7,10': { quality: 'Minor 7', root: 0 },
    '0,3,6,10': { quality: 'Half-Diminished 7', root: 0 },
    '0,3,6,9': { quality: 'Diminished 7', root: 0 },
    
    // 6th chords
    '0,4,7,9': { quality: 'Major 6', root: 0 },
    '0,3,7,9': { quality: 'Minor 6', root: 0 },
    
    // Extended chords
    '0,4,7,10,14': { quality: '9th', root: 0 },
    '0,4,7,11,14': { quality: 'Major 9', root: 0 },
    '0,3,7,10,14': { quality: 'Minor 9', root: 0 },
    '0,4,7,14': { quality: 'Add9', root: 0 },
    
    // Inversions (common ones)
    '0,3,8': { quality: 'Major', root: 8 },  // 1st inversion major
    '0,4,9': { quality: 'Minor', root: 9 },  // 1st inversion minor
    '0,5,9': { quality: 'Major', root: 5 },  // 2nd inversion major
    '0,5,8': { quality: 'Minor', root: 5 },  // 2nd inversion minor
  };
  
  // Check for exact pattern match
  if (patterns[pattern]) {
    const result = patterns[pattern];
    return {
      quality: result.quality,
      root: (bassPC + result.root) % 12
    };
  }
  
  // Fallback analysis
  const third = hasInterval(3) || hasInterval(4);
  const fifth = hasInterval(7) || hasInterval(6) || hasInterval(8);
  const seventh = hasInterval(10) || hasInterval(11);
  
  let quality = 'Unknown';
  let root = bassPC;
  
  if (hasInterval(3) && hasInterval(7)) {
    quality = 'Minor';
    if (hasInterval(10)) quality = 'Minor 7';
    else if (hasInterval(11)) quality = 'Minor Major 7';
  } else if (hasInterval(4) && hasInterval(7)) {
    quality = 'Major';
    if (hasInterval(10)) quality = 'Dominant 7';
    else if (hasInterval(11)) quality = 'Major 7';
  } else if (hasInterval(3) && hasInterval(6)) {
    quality = 'Diminished';
    if (hasInterval(9)) quality = 'Diminished 7';
    else if (hasInterval(10)) quality = 'Half-Diminished 7';
  } else if (hasInterval(4) && hasInterval(8)) {
    quality = 'Augmented';
  } else if (hasInterval(2) && hasInterval(7)) {
    quality = 'Sus2';
  } else if (hasInterval(5) && hasInterval(7)) {
    quality = 'Sus4';
  }
  
  return { quality, root };
}

// Scale detection
function detectKeyAndScale(progression) {
  const notesUsed = new Set();
  const chordRoots = [];
  const chordQualities = [];
  
  progression.chords.forEach(chord => {
    if (chord.notes && chord.notes.length > 0) {
      chord.notes.forEach(note => {
        notesUsed.add(note % 12);
      });
      
      const analysis = analyzeChord(chord.notes);
      if (analysis.root) {
        const rootIndex = NOTES.indexOf(analysis.root);
        if (rootIndex !== -1) {
          chordRoots.push(rootIndex);
          chordQualities.push(analysis.quality);
        }
      }
    }
  });
  
  if (notesUsed.size === 0) return { root: '?', scale: '?' };
  
  let bestFit = null;
  let bestScore = -1;
  
  // Test each possible root and scale
  for (let rootIdx = 0; rootIdx < 12; rootIdx++) {
    for (const [scaleName, intervals] of Object.entries(SCALES)) {
      const scaleNotes = new Set(intervals.map(i => (rootIdx + i) % 12));
      
      // Calculate fit score
      let matches = 0;
      let total = 0;
      
      notesUsed.forEach(note => {
        total++;
        if (scaleNotes.has(note)) matches++;
      });
      
      // Bonus for matching chord roots
      let rootMatches = 0;
      chordRoots.forEach(chordRoot => {
        if (scaleNotes.has(chordRoot)) rootMatches++;
      });
      
      // Special bonus for tonic as first chord
      let tonicBonus = 0;
      if (chordRoots.length > 0 && chordRoots[0] === rootIdx) {
        tonicBonus = 0.2;
      }
      
      const score = (matches / total) + (rootMatches / chordRoots.length) * 0.5 + tonicBonus;
      
      if (score > bestScore) {
        bestScore = score;
        bestFit = { root: NOTES[rootIdx], scale: scaleName };
      }
    }
  }
  
  // Require a minimum score for confidence
  if (bestScore < 0.7) {
    return { root: '?', scale: '?' };
  }
  
  return bestFit;
}

// Roman numeral generation
function generateRomanNumerals(progression) {
  if (!progression.key || progression.key.root === '?') return '';
  
  const rootIndex = NOTES.indexOf(progression.key.root);
  const scale = SCALES[progression.key.scale];
  if (!scale) return '';
  
  const romans = [];
  const romanBase = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII'];
  
  progression.chords.forEach(chord => {
    if (!chord.analysis || !chord.analysis.root) {
      romans.push('?');
      return;
    }
    
    const chordRootIndex = NOTES.indexOf(chord.analysis.root);
    const interval = (chordRootIndex - rootIndex + 12) % 12;
    
    // Find scale degree
    const degree = scale.indexOf(interval);
    if (degree === -1) {
      // Chromatic chord
      romans.push('♭' + romanBase[Math.floor(interval / 2)] || '?');
      return;
    }
    
    let roman = romanBase[degree];
    
    // Make minor chords lowercase
    if (chord.analysis.quality.includes('Minor') || 
        chord.analysis.quality.includes('Diminished')) {
      roman = roman.toLowerCase();
    }
    
    // Add quality modifiers
    if (chord.analysis.quality.includes('Diminished')) {
      roman += '°';
    } else if (chord.analysis.quality.includes('Augmented')) {
      roman += '+';
    } else if (chord.analysis.quality.includes('7')) {
      roman += '7';
    }
    
    romans.push(roman);
  });
  
  return romans.join('-');
}

// Audio playback
function initAudio() {
  if (!audioContext) {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    if (AudioContext) {
      audioContext = new AudioContext();
    }
  }
  return audioContext;
}

function playChord(midiNotes, duration = 1000) {
  const ctx = initAudio();
  if (!ctx) return;
  
  const now = ctx.currentTime;
  const noteGain = 0.15 / Math.sqrt(midiNotes.length); // Normalize volume
  
  midiNotes.forEach((midi, i) => {
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    const freq = 440 * Math.pow(2, (midi - 69) / 12);
    
    osc.frequency.value = freq;
    osc.type = 'sine';
    
    // Slight detune for richness
    osc.detune.value = (i - midiNotes.length / 2) * 2;
    
    // ADSR envelope
    gain.gain.setValueAtTime(0, now);
    gain.gain.linearRampToValueAtTime(noteGain, now + 0.02); // Attack
    gain.gain.exponentialRampToValueAtTime(noteGain * 0.7, now + 0.1); // Decay
    gain.gain.setValueAtTime(noteGain * 0.7, now + duration / 1000 - 0.05); // Sustain
    gain.gain.exponentialRampToValueAtTime(0.001, now + duration / 1000); // Release
    
    osc.connect(gain).connect(ctx.destination);
    osc.start(now);
    osc.stop(now + duration / 1000 + 0.1);
  });
}

function playProgression(chords, tempo = 120) {
  if (isPlaying) {
    stopPlayback();
    return;
  }
  
  isPlaying = true;
  const beatDuration = 60000 / tempo; // ms per beat
  let currentChord = 0;
  
  function playNext() {
    if (!isPlaying || currentChord >= chords.length) {
      stopPlayback();
      return;
    }
    
    const chord = chords[currentChord];
    if (chord.notes && chord.notes.length > 0) {
      playChord(chord.notes, beatDuration * 0.9);
      
      // Visual feedback
      const pads = document.querySelectorAll('.chord-pad');
      pads.forEach(pad => pad.classList.remove('playing'));
      if (pads[currentChord]) {
        pads[currentChord].classList.add('playing');
      }
    }
    
    currentChord++;
    playbackTimeout = setTimeout(playNext, beatDuration);
  }
  
  playNext();
}

function stopPlayback() {
  isPlaying = false;
  if (playbackTimeout) {
    clearTimeout(playbackTimeout);
    playbackTimeout = null;
  }
  document.querySelectorAll('.chord-pad').forEach(pad => {
    pad.classList.remove('playing');
  });
}

// File handling
function handleDrop(e) {
  e.preventDefault();
  e.stopPropagation();
  
  const zone = document.getElementById('dropZone');
  zone.classList.remove('dragging');
  
  const files = e.dataTransfer.files;
  if (files.length > 0) {
    processFiles(files);
  }
}

function handleDragOver(e) {
  e.preventDefault();
  e.stopPropagation();
}

function handleDragEnter(e) {
  e.preventDefault();
  document.getElementById('dropZone').classList.add('dragging');
}

function handleDragLeave(e) {
  e.preventDefault();
  if (e.target.id === 'dropZone') {
    e.target.classList.remove('dragging');
  }
}

function processFiles(files) {
  const loading = document.getElementById('loading');
  loading.classList.add('active');
  
  let processed = 0;
  const newProgressions = [];
  
  Array.from(files).forEach(file => {
    const reader = new FileReader();
    
    reader.onload = (e) => {
      try {
        const data = JSON.parse(e.target.result);
        if (data.progression) {
          const prog = processProgression(data.progression);
          if (prog) {
            newProgressions.push(prog);
          }
        }
      } catch (err) {
        console.warn(`Failed to parse ${file.name}:`, err);
      }
      
      processed++;
      if (processed === files.length) {
        finishLoading(newProgressions);
      }
    };
    
    reader.onerror = () => {
      processed++;
      if (processed === files.length) {
        finishLoading(newProgressions);
      }
    };
    
    reader.readAsText(file);
  });
}

function processProgression(data) {
  if (!data.chords || !Array.isArray(data.chords)) return null;
  
  const progression = {
    name: data.name || 'Untitled',
    chords: []
  };
  
  // Process each chord
  data.chords.forEach((chord, index) => {
    const chordData = {
      name: chord.name || `Chord ${index + 1}`,
      notes: chord.notes || [],
      analysis: null
    };
    
    // Analyze chord from MIDI notes only
    if (chordData.notes.length > 0) {
      chordData.analysis = analyzeChord(chordData.notes);
    }
    
    progression.chords.push(chordData);
  });
  
  // Detect key and scale
  progression.key = detectKeyAndScale(progression);
  
  // Generate Roman numerals
  progression.romanNumerals = generateRomanNumerals(progression);
  
  return progression;
}

function finishLoading(newProgressions) {
  progressions.push(...newProgressions);
  
  document.getElementById('loading').classList.remove('active');
  document.getElementById('statsBar').classList.remove('hidden');
  document.getElementById('filters').classList.remove('hidden');
  
  updateFilters();
  updateStats();
  render();
}

// UI Updates
function updateFilters() {
  const roots = new Set();
  const scales = new Set();
  const chordTypes = new Set();
  
  progressions.forEach(prog => {
    if (prog.key.root !== '?') {
      roots.add(prog.key.root);
      scales.add(prog.key.scale);
    }
    
    prog.chords.forEach(chord => {
      if (chord.analysis && chord.analysis.root) {
        chordTypes.add(chord.analysis.root);
      }
    });
  });
  
  // Update root filter
  const rootSelect = document.getElementById('filterRoot');
  rootSelect.innerHTML = '<option value="">All roots</option>';
  Array.from(roots).sort().forEach(root => {
    rootSelect.innerHTML += `<option value="${root}">${root}</option>`;
  });
  
  // Update scale filter
  const scaleSelect = document.getElementById('filterScale');
  scaleSelect.innerHTML = '<option value="">All scales</option>';
  Array.from(scales).sort().forEach(scale => {
    scaleSelect.innerHTML += `<option value="${scale}">${scale}</option>`;
  });
  
  // Update chord filter options
  const chordNoteSelect = document.getElementById('chordFilterNote');
  chordNoteSelect.innerHTML = '<option value="">Select note...</option>';
  NOTES.forEach(note => {
    chordNoteSelect.innerHTML += `<option value="${note}">${note}</option>`;
  });
  
  const chordQualitySelect = document.getElementById('chordFilterQuality');
  chordQualitySelect.innerHTML = '<option value="">Select quality...</option>';
  const qualities = ['Major', 'Minor', 'Dominant 7', 'Major 7', 'Minor 7', 'Diminished', 'Augmented', 'Sus2', 'Sus4'];
  qualities.forEach(q => {
    chordQualitySelect.innerHTML += `<option value="${q}">${q}</option>`;
  });
}

function updateStats() {
  const total = progressions.length;
  const shown = getFilteredProgressions().length;
  
  const keys = new Set();
  const chords = new Set();
  
  progressions.forEach(prog => {
    if (prog.key.root !== '?') {
      keys.add(`${prog.key.root} ${prog.key.scale}`);
    }
    prog.chords.forEach(chord => {
      if (chord.analysis && chord.analysis.name) {
        chords.add(chord.analysis.name);
      }
    });
  });
  
  document.getElementById('statTotal').textContent = total;
  document.getElementById('statShown').textContent = shown;
  document.getElementById('statKeys').textContent = keys.size;
  document.getElementById('statChords').textContent = chords.size;
}

// Filtering
function getFilteredProgressions() {
  let filtered = [...progressions];
  
  // Root filter
  const rootFilter = document.getElementById('filterRoot').value;
  if (rootFilter) {
    filtered = filtered.filter(p => p.key.root === rootFilter);
  }
  
  // Scale filter
  const scaleFilter = document.getElementById('filterScale').value;
  if (scaleFilter) {
    filtered = filtered.filter(p => p.key.scale === scaleFilter);
  }
  
  // Pattern filter
  const patternFilter = document.getElementById('filterPattern').value.trim();
  if (patternFilter) {
    filtered = filtered.filter(p => {
      return p.romanNumerals && p.romanNumerals.includes(patternFilter);
    });
  }
  
  // Name filter
  const nameFilter = document.getElementById('filterName').value.toLowerCase().trim();
  if (nameFilter) {
    filtered = filtered.filter(p => {
      return p.name.toLowerCase().includes(nameFilter);
    });
  }
  
  // Chord filters
  if (chordFilters.length > 0) {
    filtered = filtered.filter(prog => {
      return chordFilters.every(filter => {
        return prog.chords.some(chord => {
          if (!chord.analysis) return false;
          const matchesRoot = chord.analysis.root === filter.root;
          const matchesQuality = !filter.quality || chord.analysis.quality === filter.quality;
          return matchesRoot && matchesQuality;
        });
      });
    });
  }
  
  return filtered;
}

// Rendering
function render() {
  const container = document.getElementById('progressions');
  container.innerHTML = '';
  
  const filtered = getFilteredProgressions();
  const groupByKey = document.getElementById('groupByKey').checked;
  
  if (groupByKey) {
    renderGrouped(filtered, container);
  } else {
    renderFlat(filtered, container);
  }
  
  updateStats();
}

function renderFlat(progs, container) {
  progs.forEach(prog => {
    container.appendChild(createProgressionCard(prog));
  });
}

function renderGrouped(progs, container) {
  const groups = {};
  
  progs.forEach(prog => {
    const key = prog.key.root !== '?' ? `${prog.key.root} ${prog.key.scale}` : 'Unknown Key';
    if (!groups[key]) {
      groups[key] = [];
    }
    groups[key].push(prog);
  });
  
  Object.entries(groups).sort().forEach(([key, groupProgs]) => {
    const header = document.createElement('div');
    header.className = 'group-header';
    header.innerHTML = `
      <span>${key} (${groupProgs.length})</span>
      <span class="toggle">▼</span>
    `;
    
    const content = document.createElement('div');
    content.className = 'group-content';
    
    groupProgs.forEach(prog => {
      content.appendChild(createProgressionCard(prog));
    });
    
    header.addEventListener('click', () => {
      header.classList.toggle('collapsed');
      content.classList.toggle('collapsed');
    });
    
    container.appendChild(header);
    container.appendChild(content);
  });
}

function createProgressionCard(progression) {
  const card = document.createElement('div');
  card.className = 'progression-card';
  
  const header = document.createElement('div');
  header.className = 'progression-header';
  
  const titleSection = document.createElement('div');
  titleSection.innerHTML = `
    <div class="progression-title">${progression.name}</div>
    <div class="progression-meta">
      <span class="key">${progression.key.root} ${progression.key.scale}</span>
      ${progression.romanNumerals ? `<span class="pattern">${progression.romanNumerals}</span>` : ''}
    </div>
  `;
  
  const controls = document.createElement('div');
  controls.className = 'play-controls';
  controls.innerHTML = `
    <button class="primary" onclick="playProgression(progressions[${progressions.indexOf(progression)}].chords)">
      Play
    </button>
  `;
  
  header.appendChild(titleSection);
  header.appendChild(controls);
  card.appendChild(header);
  
  const grid = document.createElement('div');
  grid.className = 'chord-grid';
  
  const showIntervals = document.getElementById('showIntervals').checked;
  
  progression.chords.forEach((chord, i) => {
    const pad = document.createElement('div');
    pad.className = 'chord-pad';
    pad.onclick = () => {
      if (chord.notes && chord.notes.length > 0) {
        playChord(chord.notes);
        pad.classList.add('playing');
        setTimeout(() => pad.classList.remove('playing'), 300);
      }
    };
    
    let padHTML = `<div class="pad-number">PAD ${i + 1}</div>`;
    
    if (chord.analysis) {
      padHTML += `<div class="chord-name">${chord.analysis.name}</div>`;
      padHTML += `<div class="chord-quality">${chord.analysis.quality}</div>`;
      
      if (showIntervals && chord.analysis.intervals.length > 0) {
        const intervalNames = chord.analysis.intervals.map(i => INTERVAL_NAMES[i]).join('-');
        padHTML += `<div class="chord-intervals">[${intervalNames}]</div>`;
      }
      
      // Add Roman numeral if available
      if (progression.romanNumerals) {
        const romans = progression.romanNumerals.split('-');
        if (romans[i] && romans[i] !== '?') {
          padHTML += `<div class="chord-roman">${romans[i]}</div>`;
        }
      }
    }
    
    if (chord.notes && chord.notes.length > 0) {
      const noteNames = chord.notes.map(midiToNoteName).join(' ');
      padHTML += `<div class="chord-notes">${noteNames}</div>`;
    }
    
    pad.innerHTML = padHTML;
    grid.appendChild(pad);
  });
  
  card.appendChild(grid);
  return card;
}

// Chord filter management
function addChordFilter() {
  const root = document.getElementById('chordFilterNote').value;
  const quality = document.getElementById('chordFilterQuality').value;
  
  if (!root) return;
  
  const filter = { root, quality };
  chordFilters.push(filter);
  
  updateChordTags();
  render();
  
  // Reset selects
  document.getElementById('chordFilterNote').value = '';
  document.getElementById('chordFilterQuality').value = '';
}

function removeChordFilter(index) {
  chordFilters.splice(index, 1);
  updateChordTags();
  render();
}

function updateChordTags() {
  const container = document.getElementById('chordTags');
  container.innerHTML = '';
  
  chordFilters.forEach((filter, i) => {
    const tag = document.createElement('div');
    tag.className = 'chord-tag';
    const label = filter.quality ? `${filter.root} ${filter.quality}` : filter.root;
    tag.innerHTML = `
      ${label}
      <button onclick="removeChordFilter(${i})">×</button>
    `;
    container.appendChild(tag);
  });
}

function clearAllFilters() {
  chordFilters = [];
  document.getElementById('filterRoot').value = '';
  document.getElementById('filterScale').value = '';
  document.getElementById('filterPattern').value = '';
  document.getElementById('filterName').value = '';
  document.getElementById('chordFilterNote').value = '';
  document.getElementById('chordFilterQuality').value = '';
  updateChordTags();
  render();
}

// Event listeners
document.addEventListener('DOMContentLoaded', () => {
  const dropZone = document.getElementById('dropZone');
  const fileInput = document.getElementById('fileInput');
  
  dropZone.addEventListener('drop', handleDrop);
  dropZone.addEventListener('dragover', handleDragOver);
  dropZone.addEventListener('dragenter', handleDragEnter);
  dropZone.addEventListener('dragleave', handleDragLeave);
  
  dropZone.addEventListener('click', () => fileInput.click());
  fileInput.addEventListener('change', (e) => {
    if (e.target.files.length > 0) {
      processFiles(e.target.files);
    }
  });
  
  // Filter listeners
  document.getElementById('filterRoot').addEventListener('change', render);
  document.getElementById('filterScale').addEventListener('change', render);
  document.getElementById('filterPattern').addEventListener('input', render);
  document.getElementById('filterName').addEventListener('input', render);
  document.getElementById('groupByKey').addEventListener('change', render);
  document.getElementById('showIntervals').addEventListener('change', render);
  
  document.getElementById('addChordFilter').addEventListener('click', addChordFilter);
  document.getElementById('clearAllFilters').addEventListener('click', clearAllFilters);
  
  // Keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      stopPlayback();
    }
  });
});
</script>
</body>
</html>
